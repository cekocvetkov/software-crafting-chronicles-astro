---
title: "Github Actions: Execute kubectl commands from a local cluster with the help of self-hosted runner"
slug: "self-hosted"
date: 2024-03-12
tags: ["github", "kubernetes"]
---

# Github Actions: Execute kubectl commands from a local cluster with the help of self-hosted runner more more more mre

In this article, we will see how to setup self-hosted runner in Kubernetes for a github repository and run kubectl commands from a GitHub Actions pipeline on the same cluster where the self-hosted runner is running.

**What do we need to follow along:**

1. Local Kubernetes cluster (You can use minikube or kind, or the Docker Desktop Kubernetes Solution, or whatever you like)
2. Github Account (easy)
3. Basic Kubernetes and Github Actions knowledge

**Alternatives:**

Of course there’s another way to run kubectl commands from GitHub Actions.
For example using a kubeconfig file. The kubeconfig file contains information about the cluster,
including the API server endpoint, the cluster’s CA certificate, and the credentials for a user or service account. This is a way to authenticate and authorize kubectl to access a specific Kubernetes cluster. The best way to do this, is to add the kubeconfig file content as a secret in Github.

Of course there’s another way to run kubectl commands from GitHub Actions.
For example using a kubeconfig file. The kubeconfig file contains information about the cluster,
including the API server endpoint, the cluster’s CA certificate, and the credentials for a user or service account. This is a way to authenticate and authorize kubectl to access a specific Kubernetes cluster. The best way to do this, is to add the kubeconfig file content as a secret in Github.

Of course there’s another way to run kubectl commands from GitHub Actions.
For example using a kubeconfig file. The kubeconfig file contains information about the cluster,
including the API server endpoint, the cluster’s CA certificate, and the credentials for a user or service account. This is a way to authenticate and authorize kubectl to access a specific Kubernetes cluster. The best way to do this, is to add the kubeconfig file content as a secret in Github.

### Zeko , right

sS

Of course there’s another way to run kubectl commands from GitHub Actions.
For example using a kubeconfig file. The kubeconfig file contains information about the cluster,
including the API server endpoint, the cluster’s CA certificate, and the credentials for a user or service account. This is a way to authenticate and authorize kubectl to access a specific Kubernetes cluster. The best way to do this, is to add the kubeconfig file content as a secret in Github.

### Zeko 22222, right

sS

Of course there’s another way to run kubectl commands from GitHub Actions.
For example using a kubeconfig file. The kubeconfig file contains information about the cluster,
including the API server endpoint, the cluster’s CA certificate, and the credentials for a user or service account. This is a way to authenticate and authorize kubectl to access a specific Kubernetes cluster. The best way to do this, is to add the kubeconfig file content as a secret in Github.

### Zeko 333333, right

sS

Of course there’s another way to run kubectl commands from GitHub Actions.
For example using a kubeconfig file. The kubeconfig file contains information about the cluster,
including the API server endpoint, the cluster’s CA certificate, and the credentials for a user or service account. This is a way to authenticate and authorize kubectl to access a specific Kubernetes cluster. The best way to do this, is to add the kubeconfig file content as a secret in Github.

<br></br>Text

<br></br>Text

<br></br>Text

<br></br>Text

<br></br>Text

<br></br>
Text

<br></br>Text

<br></br>Text

<br></br>Text

<br></br>Text

<br></br>Text

<br></br>Text

<br></br>Text

<br></br>
